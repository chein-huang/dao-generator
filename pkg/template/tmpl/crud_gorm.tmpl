
// Code generated by protoc-gen-go. DO NOT EDIT.
package dao

import (
	"context"

	"github.com/pkg/errors"
	"gorm.io/gorm"
	"time"

    {{- range .Imports }}
    "{{ . }}"
    {{- end }}
)

type {{ .StructName }}Dao interface {
	Create{{ .StructName }}(ctx context.Context, approvalInfo *{{ .ModelPackage }}.{{ .StructName }}) error
	Get{{ .StructName }}(ctx context.Context, opts ...DaoOpt) (*{{ .ModelPackage }}.{{ .StructNameWithPreload }}, error)
	Search{{ .StructName }}(ctx context.Context, page, pageSize int, isAll bool, opts ...DaoOpt) ([]*{{ .ModelPackage }}.{{ .StructNameWithPreload }}, int, error)
	Update{{ .StructName }}(ctx context.Context, opts ...DaoOpt) (*{{ .ModelPackage }}.{{ .StructNameWithPreload }}, error)
}

func (d *dao) Create{{ .StructName }}(ctx context.Context, v *{{ .ModelPackage }}.{{ .StructName }}) error {
	tx := d.tryGetTx(ctx)

	err := tx.Create(&v).Error
	if err != nil {
		return errors.WithStack(err)
	}

	return nil
}

func (d *dao) Get{{ .StructName }}(ctx context.Context, opts ...DaoOpt) (*{{ .ModelPackage }}.{{ .StructNameWithPreload }}, error) {
	opt := d.fromDaoOptions(ctx, opts...)

	var v {{ .ModelPackage }}.{{ .StructNameWithPreload }}
	err := opt.tx.Take(&v).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			err = Err{{ .StructName }}NotFound
		}
		return nil, opt.wrapError(err)
	}

	return &v, nil
}

func (d *dao) Search{{ .StructName }}(ctx context.Context, page, pageSize int, isAll bool, opts ...DaoOpt) ([]*{{ .ModelPackage }}.{{ .StructNameWithPreload }}, int, error) {
	opt := d.fromDaoOptions(ctx, opts...)

	count := int64(0)
	err := opt.tx.Model(&{{ .ModelPackage }}.{{ .StructName }}{}).Count(&count).Error
	if err != nil {
		return nil, 0, opt.wrapError(err)
	}

	if !isAll {
		opt.tx = opt.tx.Offset((page - 1) * pageSize).Limit(pageSize)
	}

	v := []*{{ .ModelPackage }}.{{ .StructNameWithPreload }}{}
	err = opt.tx.Find(&v).Error
	if err != nil {
		return nil, 0, opt.wrapError(err)
	}

	return v, int(count), nil
}

func (d *dao) Update{{ .StructName }}(ctx context.Context, opts ...DaoOpt) (*{{ .ModelPackage }}.{{ .StructNameWithPreload }}, error) {
	opt := d.fromDaoOptions(ctx, opts...)

	v, err := d.Get{{ .StructName }}(ctx, opts...)
	if err != nil {
		return nil, err
	}

	if len(opt.updateMap) == 0 {
		return v, nil
	}

{{- if .IsPreload }}
	err = opt.tx.Model(v.{{ .StructName }}).Updates(opt.updateMap).Error
{{- else }}
	err = opt.tx.Model(v).Updates(opt.updateMap).Error
{{- end }}
	if err != nil {
		return nil, opt.wrapError(err)
	}

	return v, nil
}

type {{ .StructNameSmallCamel }}Queries struct{}

// {{ .StructName }}Qs 这种方式避免其他开发者用错option
var {{ .StructName }}Qs {{ .StructNameSmallCamel }}Queries

{{- range .Fields }}
func (*{{ $.StructNameSmallCamel }}Queries) With{{ .Name }}(v {{ .Type }}) DaoOpt {
	return daoOpt(func(opt *daoOptions) {
		queryParams := newQueryParams("{{ .NameSnake }} = ?", v)
		opt.tx = queryParams.where(opt.tx)
		opt.queryParams = append(opt.queryParams, queryParams)
	})
}
{{ "" }}
{{- if .In }}
func (*{{ $.StructNameSmallCamel }}Queries) WithIn{{ .Name }}(vs []{{ .Type }}) DaoOpt {
	return daoOpt(func(opt *daoOptions) {
        queryParams := newQueryParams("{{ .NameSnake }} in (?)", vs)
		opt.tx = queryParams.where(opt.tx)
		opt.queryParams = append(opt.queryParams, queryParams)
	})
}
{{ "" }}
{{- end }}
{{- if .Order }}
func (*{{ $.StructNameSmallCamel }}Queries) WithOrderBy{{ .Name }}(desc bool) DaoOpt {
	return daoOpt(func(opt *daoOptions) {
		orderStr := "{{ .NameSnake }}"
		if desc {
			orderStr += " DESC"
		}
		opt.tx = opt.tx.Order(orderStr)
	})
}
{{ "" }}
{{- end }}
{{- if .Range }}
func (*{{ $.StructNameSmallCamel }}Queries) With{{ .Name }}Lt(v {{ .Type }}) DaoOpt {
	return daoOpt(func(opt *daoOptions) {
        queryParams := newQueryParams("{{ .NameSnake }} < ?", v)
        opt.tx = queryParams.where(opt.tx)
        opt.queryParams = append(opt.queryParams, queryParams)
    })
}

func (*{{ $.StructNameSmallCamel }}Queries) With{{ .Name }}Lte(v {{ .Type }}) DaoOpt {
	return daoOpt(func(opt *daoOptions) {
        queryParams := newQueryParams("{{ .NameSnake }} <= ?", v)
        opt.tx = queryParams.where(opt.tx)
        opt.queryParams = append(opt.queryParams, queryParams)
    })
}

func (*{{ $.StructNameSmallCamel }}Queries) With{{ .Name }}Gt(v {{ .Type }}) DaoOpt {
	return daoOpt(func(opt *daoOptions) {
        queryParams := newQueryParams("{{ .NameSnake }} > ?", v)
        opt.tx = queryParams.where(opt.tx)
        opt.queryParams = append(opt.queryParams, queryParams)
    })
}

func (*{{ $.StructNameSmallCamel }}Queries) With{{ .Name }}Gte(v {{ .Type }}) DaoOpt {
	return daoOpt(func(opt *daoOptions) {
        queryParams := newQueryParams("{{ .NameSnake }} >= ?", v)
        opt.tx = queryParams.where(opt.tx)
        opt.queryParams = append(opt.queryParams, queryParams)
    })
}
{{ "" }}
{{- end }}
{{- end }}
{{- range .Preloads }}
func (*{{ $.StructNameSmallCamel }}Queries) WithPreload{{ .Name }}() DaoOpt {
	return daoOpt(func(opt *daoOptions) {
        {{- if .OrderBy }}
		opt.tx = opt.tx.Preload("{{ .Name }}", func(db *gorm.DB) *gorm.DB {
			return db.Order("{{ .OrderBy }}")
		})
        {{- else }}
        opt.tx = opt.tx.Preload("{{ .Name }}")
        {{- end }}
	})
}
{{ "" }}
{{- end }}
// WARNING: 不建议用这个方式，需要确保期望查询的字段的值不为零值
func (*{{ .StructNameSmallCamel }}Queries) WithModel(v *{{ .ModelPackage }}.{{ .StructName }}) DaoOpt {
	return daoOpt(func(opt *daoOptions) {
		opt.tx = opt.tx.Where(v)
		// 这里只是记录
		queryParams := newQueryParams("model", v)
		opt.queryParams = append(opt.queryParams, queryParams)
	})
}

type {{ .StructNameSmallCamel }}Updates struct{}

// {{ .StructName }}Updates 这种方式避免其他开发者用错option
var {{ .StructName }}Updates {{ .StructNameSmallCamel }}Updates

{{- range .Fields }}
func (*{{ $.StructNameSmallCamel }}Updates) WithUpdate{{ .Name }}(v {{ .Type }}) DaoOpt {
	return daoOpt(func(opt *daoOptions) {
		opt.setUpdateMap("{{ .NameSnake }}", v)
	})
}
{{ "" }}
{{- end }}